
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
<title>栈 - noipxu - 博客园</title>
<meta property="og:description" content="栈是只能在某一端插入和删除的特殊线性表。 用桶堆积物品，先推进来的压在底下，随后一件一件往上堆。取走时，只能从上面一件一件取。堆和取都在顶部进行，底部一般是不动的。 栈就是一种类似桶堆积物品的数据结构" />
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/HabaHaba/bundle-HabaHaba.css?v=UPtVEp5c5COz7ailJedUlYBaufBzZ-ATkRtra5Su1jc1"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/HabaHaba/bundle-HabaHaba-mobile.css?v=d9LctKHRIQp9rreugMcQ1-UJuq_j1fo0GZXTXj8Bqrk1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/shnoip/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/shnoip/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/shnoip/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'shnoip', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=oVrWjmbP-rXxVp7O71kev8vWEZCetdwYaIziKHJCYc41" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<table width="100%" class="Framework" cellspacing="0" cellpadding="0">
	<tr>
		<td colspan="2">
			
<div id="top">
<table width="100%" cellpadding="8" cellspacing="0">
	<tr>
		<td nowrap>
			<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/shnoip/">NOIP程序设计</a></h1>
			积跬步,至千里……
		</td>
	</tr>
</table>
</div>
<div id="sub"></div>


</td>
	</tr>
	<tr>
		<td class="LeftCell">
			<div id="leftmenu">
                
                    
<h3>导航</h3>
<ul>
	<li>
		
	<li>
		
	<li>
		
	<li>
		
	<li>
		
	<li>
		<a id="blog_nav_admin" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

                    
                    <div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
                    <div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
                	        
			</div>
		</td>
		<td class="MainCell" width="100%">
			<div id="main">
				
<div id="post_detail">
	<div class="post">
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="singleposttitle" href="https://www.cnblogs.com/shnoip/p/6155334.html">栈</a>
			</h2>
 			Posted on <span id="post-date">2016-12-10 12:04</span> <a href='https://www.cnblogs.com/shnoip/'>noipxu</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=6155334" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6155334);return false;">收藏</a>
			<script type="text/javascript">var allowComments=true,cb_blogId=319781,cb_entryId=6155334,cb_blogApp=currentBlogApp,cb_blogUserGuid='62f2a97c-b1b6-e611-845c-ac853d9f53ac',cb_entryCreatedDate='2016/12/10 12:04:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
			
		</div>
		<div class="postbody"><div id="cnblogs_post_body" class="blogpost-body"><p><span style="font-size: 16px">栈是只能在某一端插入和删除的特殊线性表。</span></p>
<p><span style="font-size: 16px">用桶堆积物品，先推进来的压在底下，随后一件一件往上堆。取走时，只能从上面一件一件取。堆和取都在顶部进行，底部一般是不动的。</span></p>
<p><span style="font-size: 16px">栈就是一种类似桶堆积物品的数据结构，进行删除和插入的一端称栈顶，另一端称栈底。插入称为进栈（PUSH），删除则称为出栈（POP），栈也称为后进先出表（LIFO表）。</span></p>
<p><span style="font-size: 16px">一个栈可以用定长为N的数组S来表示，用一个栈指针TOP指向栈项。若TOP=0，表示栈空，TOP=N时，表示栈满。进栈时TOP加1，出栈时TOP减1，当TOP&lt;0时为下溢。栈指针在运算中永远指向栈项。</span></p>
<p><span style="font-size: 16px">一、进栈（PUSH）算法</span><br><span style="font-size: 16px">1、若TOP&gt;=n时，则给出溢出信息，作出错处理（进栈前首先检查栈是否已满，满则溢出；不满则运行第2步）</span><br><span style="font-size: 16px">2、置TOP=TOP+1（栈指针加1，指向进栈地址）</span><br><span style="font-size: 16px">3、S(TOP)=X，结束（X为新进栈的元素）</span></p>
<p><span style="font-size: 16px">二、出栈（POP）算法</span><br><span style="font-size: 16px">1、若TOP&lt;=0，则给出下溢信息，作出错处理（出栈前先检查是否已为空栈，空则下溢；不空则运行第2步）</span><br><span style="font-size: 16px">2、X=S(TOP)，（出栈后的元素赋给X）</span><br><span style="font-size: 16px">3、TOP=TOP-1，结束（栈指针减1，指向栈顶）</span></p>
<p><span style="font-size: 16px">进栈、出栈的Pascal实现过程程序：</span></p>
<p><span style="font-size: 16px">const n=100;</span><br><span style="font-size: 16px">type stack=array[1..n] of integer;</span></p>
<p><span style="font-size: 16px">procedure push(var s:stack; var top,x:integer); //进栈</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; if top=n then writeln('overflow')</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else begin top:=top+1;s[top]:=x;end;</span><br><span style="font-size: 16px">end;</span></p>
<p><span style="font-size: 16px">procedure pop(var s:stack; var top,y:integer); //出栈</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; if top=0 then writeln('underflow')</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else begin y:=s[top];top:=top-1;end;</span><br><span style="font-size: 16px">end;</span></p>
<p><span style="font-size: 16px">对于出栈运算中的“下溢”，程序中仅给出了一个标志信息，而在实际应用中，下溢可用来作为控制程序转移的判断标志，是十分有用的。对于入栈运算中的“上溢”，则是一种致命的错误，将使程序无法继续运行，所以要高潮避免。</span></p>
<p><span style="font-size: 16px">例1：进制转换</span><br><span style="font-size: 16px">问题描述：读入一个十进制数和n，这个十进制数转换成n进制数</span></p>
<p><span style="font-size: 16px">参考程序：</span><br><span style="font-size: 16px">const size=100;</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; a:array[1..size] of integer;</span><br><span style="font-size: 16px">&nbsp; n,d,i,j:integer;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; write('Please enter a number(n) base 10:');readln(n);</span><br><span style="font-size: 16px">&nbsp; write('Please enter a number(d):');readln(d);</span><br><span style="font-size: 16px">&nbsp; i:=0;</span><br><span style="font-size: 16px">&nbsp; repeat</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; inc(i);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; a[i]:=n mod d;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; n:=n div d;</span><br><span style="font-size: 16px">&nbsp; until n=0;</span><br><span style="font-size: 16px">&nbsp; for j:=i downto 1 do write(a[j]:3);</span><br><span style="font-size: 16px">end.</span></p>
<p><span style="font-size: 16px">例2：括号的匹配（表达式的合法性检查）</span><br><span style="font-size: 16px">问题描述：</span><br><span style="font-size: 16px">假设一个表达式有英文字母（小写）、运算符（+、-、*、/）和左右小（圆）括号构成，以“@”作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则返回“YES”；否则返回“NO”。假设表达式长度小于255，左圆括号少于20个。</span></p>
<p><span style="font-size: 16px">问题分析：</span><br><span style="font-size: 16px">假设输入的字符串存储在c中（var c:string;）</span><br><span style="font-size: 16px">我们可以定义一个栈：</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; s:array[1..maxn] of char;</span><br><span style="font-size: 16px">&nbsp; top:integer;</span><br><span style="font-size: 16px">用它来存放表达式中从左往右的左圆括号（maxn=20）</span></p>
<p><span style="font-size: 16px">算法的思路为：顺序（从左往右）扫描表达式的每个字符c[i]，若是“(”，则让它进栈；若遇到的是“)”，则让栈顶元素出栈；当栈发生下溢或当表达式处理完毕而栈非空时，都表示不匹配，返回“NO”；否则表示匹配，返回“YES”。</span></p>
<p><span style="font-size: 16px">参考程序：</span><br><span style="font-size: 16px">const maxn=20;</span><br><span style="font-size: 16px">var c:string;</span><br><span style="font-size: 16px">function judge(c:string):boolean;</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; s:array[1..maxn] of char;</span><br><span style="font-size: 16px">&nbsp; top,i:integer;</span><br><span style="font-size: 16px">&nbsp; ch:char;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; judge:=true;top:=0;</span><br><span style="font-size: 16px">&nbsp; i:=1;ch:=c[i];</span><br><span style="font-size: 16px">&nbsp; while ch&lt;&gt;'@' do begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; if (ch='(') or (ch=')') then</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ch of</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(': begin top:=top+1;s[top]:='(';end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ')': if top&gt;0 then top:=top-1</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else begin judge:=false;exit;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; i:=i+1;ch:=c[i];</span><br><span style="font-size: 16px">&nbsp; end;</span><br><span style="font-size: 16px">&nbsp; if top&lt;&gt;0 then judge:=false;</span><br><span style="font-size: 16px">end;</span></p>
<p><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; readln(c);</span><br><span style="font-size: 16px">&nbsp; if judge(c) then writeln('YES')</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else writeln('NO');</span><br><span style="font-size: 16px">end.</span></p>
<p><span style="font-size: 16px">例3：编程求一个后缀表达式的值</span><br><span style="font-size: 16px">问题描述：</span><br><span style="font-size: 16px">从键盘读入一个后缀表达式（字符串），只含有0-9组成的运算数及加、减、乘、除（+、-、*、/）四种运算符，每个运算数之间用一个空格隔开，不需要判断给你的表达式是否合法。</span></p>
<p><span style="font-size: 16px">算法分析：</span><br><span style="font-size: 16px">后缀表达式的处理过程如下：扫描后缀表达式，凡遇到操作数则将之压进堆栈，遇运算符则从堆栈中弹出两个操作数进行该运算，将运算结束压栈，然后继续扫描，直到后缀表达式被扫描完毕为止，此时栈底元素即为该后缀表达式的值。</span><br><span style="font-size: 16px">如：16-9*(4+3)转换成后缀表达式为：16 9 4 3 +*-</span><br><span style="font-size: 16px">计算结果为-47</span></p>
<p><span style="font-size: 16px">参考程序一：</span><br><span style="font-size: 16px">const maxn=20;</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; stack:array[1..maxn] of integer;</span><br><span style="font-size: 16px">&nbsp; s:string;</span><br><span style="font-size: 16px">function comp(s:string):integer;</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; ch:char;</span><br><span style="font-size: 16px">&nbsp; i,top,x,y,z:integer;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; top:=0;i:=1;ch:=s[i];</span><br><span style="font-size: 16px">&nbsp; while i&lt;=length(s) do begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; case ch of</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '0'..'9': begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x:=0;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ch&lt;&gt;' ' do begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x:=x*10+ord(ch)-48;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i:=i+1;ch:=s[i];</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top:=top+1;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack[top]:=x;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '+': begin x:=stack[top];top:=top-1;y:=stack[top];z:=y+x;stack[top]:=z;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '-': begin x:=stack[top];top:=top-1;y:=stack[top];z:=y-x;stack[top]:=z;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '*': begin x:=stack[top];top:=top-1;y:=stack[top];z:=y*x;stack[top]:=z;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/': begin x:=stack[top];top:=top-1;y:=stack[top];z:=y div x;stack[top]:=z;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; i:=i+1;ch:=s[i];</span><br><span style="font-size: 16px">&nbsp; end;</span><br><span style="font-size: 16px">&nbsp; comp:=stack[top];</span><br><span style="font-size: 16px">end;</span></p>
<p><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; readln(s);</span><br><span style="font-size: 16px">&nbsp; writeln('result=',comp(s));</span><br><span style="font-size: 16px">end.</span></p>
<p><span style="font-size: 16px">&nbsp;</span></p>
<p><span style="font-size: 16px">参考程序二：</span><br><span style="font-size: 16px">type</span><br><span style="font-size: 16px">&nbsp; stack=record</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; data:array[1..100] of real;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; top:0..100;</span><br><span style="font-size: 16px">&nbsp; end;</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; s:stack;</span><br><span style="font-size: 16px">&nbsp; ch:char;</span><br><span style="font-size: 16px">&nbsp; i:integer;</span><br><span style="font-size: 16px">&nbsp; x:real;</span><br><span style="font-size: 16px">&nbsp; a:array[1..30] of char;</span><br><span style="font-size: 16px">function pop(var s:stack):real;&nbsp; //出栈</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; pop:=s.data[s.top];</span><br><span style="font-size: 16px">&nbsp; s.top:=s.top-1;</span><br><span style="font-size: 16px">end;</span><br><span style="font-size: 16px">procedure push(var s:stack;x:real);&nbsp; //入栈</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; s.top:=s.top+1;</span><br><span style="font-size: 16px">&nbsp; s.data[s.top]:=x;</span><br><span style="font-size: 16px">end;</span></p>
<p><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; i:=0;</span><br><span style="font-size: 16px">&nbsp; repeat&nbsp; //将表达式存入数组a，以“@”作为表达式的结束符</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; i:=i+1;read(a[i]);</span><br><span style="font-size: 16px">&nbsp; until a[i]='@';</span><br><span style="font-size: 16px">&nbsp; s.top:=0;&nbsp; //清空栈</span><br><span style="font-size: 16px">&nbsp; i:=1;&nbsp; //i为数组a的下标</span><br><span style="font-size: 16px">&nbsp; ch:=a[i];</span><br><span style="font-size: 16px">&nbsp; while ch&lt;&gt;'@' do begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; case ch of</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '0'..'9': begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x:=0;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ch&lt;&gt;' ' do begin x:=x*10+ord(ch)-48;i:=i+1;ch:=a[i];end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '+': x:=pop(s)+pop(s);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '-': begin x:=pop(s);x:=pop(s)-x;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '*': x:=pop(s)*pop(s);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/': begin x:=pop(s);x:=pop(s)/x;end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; push(s,x);&nbsp; //将上面得到的x入栈</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; i:=i+1;ch:=a[i];</span><br><span style="font-size: 16px">&nbsp; end;</span><br><span style="font-size: 16px">&nbsp; writeln(pop(s));</span><br><span style="font-size: 16px">end.</span></p>
<p><span style="font-size: 16px">栈的用途极为广泛，在源程序编译中表达式的计算、过程的嵌套调用和递归调用等都要用到栈。源程序编译中，若要把一个有表达式的赋值语句翻译成正确求值的机器语言，首先应正确地解释表达式，例如：4+8*2-3</span><br><span style="font-size: 16px">一般表达式中会遇到操作数、运算符和语句结束符等，以算术运算符为例，对每种运算赋予一个优先数，如：</span><br><span style="font-size: 16px">运算符：* / + -</span><br><span style="font-size: 16px">优先数：2 2 1 1</span><br><span style="font-size: 16px">（语句结束符“;”的优先数为零）</span><br><span style="font-size: 16px">在运算过程中，优先数高的运算符应先进行运算（但遇到括号时，应另作处理）。按这样的规定，对表达式4+8*2-3自左向右进行运算时，其计算顺序就被唯一地确定下来了。计算机顺序确定后，在对表达式进行编译时，一般设立两个栈，一个称为运算符栈（OPS），另一个称为操作数栈（OVS），以便分别存放表达式中的运算符和操作数。编译程序自左向右扫描表达式直至语句结束，其处理原则是：</span><br><span style="font-size: 16px">1、凡遇到操作数，一律进入操作数栈</span><br><span style="font-size: 16px">2、当遇到运算符时，则将运算符的优先数与运算符栈中的栈顶元素的优先数相比较；若该运算符的优先数大，则进栈；反之，则取出栈项的运算符，并在操作数栈中连续取出两个栈顶元素作为运算对象，并将运算结果存入操作数栈，然后继续比较该运算符与栈顶元素的优先数</span></p>
<p><span style="font-size: 16px">对表达式4+8*2-3，当扫描到+号和*号时都要将运算符入栈，接着扫描到-号，其优先数小于*号所以*号退栈，并执行8*2，将结果16再存入操作数栈；再将-号的优先数与运算符栈的栈顶元素+号的优先数相比较，两者相等，所以再将加号退栈，执行4+16，将结果20存入栈，接着由于运算栈已空，所以-号入栈。当扫描到3时，操作数入栈；当扫描到“；”时，其优先数最低，所以-号退栈，并执行20-3，将结果17存入栈，因已扫描到语句结束符，所以表达式的求值结束，结果为17。</span></p>
<p><span style="font-size: 16px">例4：模拟计算机处理算术表达式过程，从键盘上输入算术表达式串（只含+、-、*、/运算符，允许含括号），输出算术表达式的值。设输入的且达式串都是合法的。</span><br><span style="font-size: 16px">算法分析：</span><br><span style="font-size: 16px">建立两个栈，一个是操作数栈（number），一个是运算符栈（symbol），根据运算符的优先级对两个栈进行相应的操作。</span></p>
<p><span style="font-size: 16px">const</span><br><span style="font-size: 16px">&nbsp; max=100;</span><br><span style="font-size: 16px">var</span><br><span style="font-size: 16px">&nbsp; number:array[0..max] of integer;</span><br><span style="font-size: 16px">&nbsp; symbol:array[1..max] of char;</span><br><span style="font-size: 16px">&nbsp; s,t:string;</span><br><span style="font-size: 16px">&nbsp; i,j,p,code:integer;</span><br><span style="font-size: 16px">procedure push;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; inc(p);</span><br><span style="font-size: 16px">&nbsp; symbol[p]:=s[i];</span><br><span style="font-size: 16px">end;</span><br><span style="font-size: 16px">procedure pop;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; dec(p);</span><br><span style="font-size: 16px">&nbsp; case symbol[p+1] of</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; '+': inc(number[p],number[p+1]);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; '-': dec(number[p],number[p+1]);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; '*': number[p]:=number[p]*number[p+1];</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; '/': number[p]:=number[p] div number[p+1];</span><br><span style="font-size: 16px">&nbsp; end;</span><br><span style="font-size: 16px">end;</span><br><span style="font-size: 16px">function can:boolean;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; can:=true;</span><br><span style="font-size: 16px">&nbsp; if (s[i] in ['+','-']) and (symbol[p]&lt;&gt;'(') then exit;</span><br><span style="font-size: 16px">&nbsp; if (s[i] in ['*','/']) and (symbol[p] in ['*','/']) then exit;</span><br><span style="font-size: 16px">&nbsp; can:=false;</span><br><span style="font-size: 16px">end;</span><br><span style="font-size: 16px">begin</span><br><span style="font-size: 16px">&nbsp; readln(s);</span><br><span style="font-size: 16px">&nbsp; s:='('+s+')';</span><br><span style="font-size: 16px">&nbsp; i:=1;p:=0;</span><br><span style="font-size: 16px">&nbsp; while i&lt;=length(s) do begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; while s[i]='(' do begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push;inc(i);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; j:=i;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; repeat</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc(i);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; until (s[i]&lt;'0') or (s[i]&gt;'9');</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; t:=copy(s,j,i-j);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; val(t,number[p],code);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; repeat</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s[i]=')' then begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while symbol[p]&lt;&gt;'(' do pop;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec(P);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number[p]:=number[p+1];</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end else begin</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while can do pop;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc(i);</span><br><span style="font-size: 16px">&nbsp;&nbsp;&nbsp; until (i&gt;length(s)) or (s[i-1]&lt;&gt;')');</span><br><span style="font-size: 16px">&nbsp; end;</span><br><span style="font-size: 16px">&nbsp; write('result=',number[0]);</span><br><span style="font-size: 16px">end.</span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>

</div>
	</div></div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='cnblogs_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>

<script>
  googletag.cmd.push(function() {
    googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.enableServices();
  });
</script>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'>
    <script>
    if (new Date() >= new Date(2018, 9, 13)) {
        googletag.cmd.push(function() { googletag.display('div-gpt-ad-1539008685004-0'); });
    }
    </script>
    </div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


			</div>
		</td>
	</tr>
	<tr>
		<td colspan="2" class="FooterCell">
			
<p id="footer">
	Powered by: 
	<br />
	
	<a id="Footer1_Hyperlink3" NAME="Hyperlink1" href="https://www.cnblogs.com/"><font face="Verdana">博客园</font></a>
	<br />
	Copyright &copy; noipxu
</p>
		</td>
	</tr>
</table>


</body>
</html>
